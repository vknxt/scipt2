--[[
    ╔═══╗─────────╔╗────────╔═══╗
    ║╔═╗║────────╔╝╚╗───────║╔═╗║
    ║╚══╦══╦══╦═╗╠╗╔╬══╦╗╔╗─║╚═╝╠══╦═╗
    ╚══╗║╔═╣║═╣╔╗╣║║║╔╗║╚╝║─║╔══╣╔╗║╔╝
    ║╚═╝║╚═╣║═╣║║║║╚╣╔╗║║║║─║║──║╚╝║║
    ╚═══╩══╩══╩╝╚╝╚═╩╝╚╩╩╩╝─╚╝──╚══╩╝
    
    Premium Script v2.1.0
    Last Updated: 2024
]]

-- Verificação inicial e proteção
if not game:IsLoaded() then game.Loaded:Wait() end
if getgenv().ScriptLoaded then return end
getgenv().ScriptLoaded = true

-- Serviços com proteção contra erros
local Services = setmetatable({
    Loaded = {},
}, {
    __index = function(self, service)
        if self.Loaded[service] then 
            return self.Loaded[service]
        end
        
        local success, result = pcall(function()
            return game:GetService(service)
        end)
        
        if success then
            self.Loaded[service] = result
            return result
        end
        
        warn("❌ Falha ao carregar serviço:", service)
        return nil
    end
})

-- Carregar serviços essenciais
local Players = Services.Players
local RunService = Services.RunService
local UserInputService = Services.UserInputService
local TweenService = Services.TweenService
local HttpService = Services.HttpService
local CoreGui = Services.CoreGui
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Verificações de compatibilidade
local function CheckCompatibility()
    local requirements = {
        Drawing = typeof(Drawing) == "table",
        NewDrawing = typeof(Drawing.new) == "function",
        Workspace = typeof(workspace) == "Instance",
        Camera = typeof(Camera) == "Instance"
    }
    
    for name, passed in pairs(requirements) do
        if not passed then
            warn("❌ Requisito não atendido:", name)
            return false
        end
    end
    
    return true
end

if not CheckCompatibility() then return end

-- Sistema de Notificações Aprimorado
local Notifications = {
    Active = {},
    MaxNotifications = 5,
    Duration = 5,
    
    Create = function(self, title, message, type)
        -- Remover notificações antigas se necessário
        while #self.Active >= self.MaxNotifications do
            local oldest = table.remove(self.Active, 1)
            if oldest.Object then
                oldest.Object:Destroy()
            end
        end
        
        -- Criar nova notificação
        local notification = Drawing.new("Text")
        notification.Text = string.format("【%s】%s", title, message)
        notification.Size = 18
        notification.Center = false
        notification.Outline = true
        notification.Position = Vector2.new(10, 10 + (#self.Active * 25))
        
        -- Definir cor baseada no tipo
        local colors = {
            Success = Color3.fromRGB(0, 255, 140),
            Warning = Color3.fromRGB(255, 165, 0),
            Error = Color3.fromRGB(255, 0, 85),
            Info = Color3.fromRGB(100, 200, 255)
        }
        notification.Color = colors[type] or colors.Info
        notification.Visible = true
        
        -- Animar entrada
        local startTime = tick()
        local function animate()
            local elapsed = tick() - startTime
            local alpha = math.clamp(elapsed / 0.3, 0, 1)
            notification.Transparency = 1 - alpha
            
            if elapsed >= self.Duration then
                -- Animar saída
                local fadeOut = (elapsed - self.Duration) / 0.3
                notification.Transparency = fadeOut
                
                if fadeOut >= 1 then
                    notification:Remove()
                    return false
                end
            end
            return true
        end
        
        table.insert(self.Active, {
            Object = notification,
            Animate = animate
        })
    end,
    
    Update = function(self)
        for i = #self.Active, 1, -1 do
            local notif = self.Active[i]
            if not notif.Animate() then
                table.remove(self.Active, i)
            end
        end
    end
}

-- Sistema de Performance Aprimorado
local Performance = {
    FPS = {
        Current = 0,
        Samples = {},
        MaxSamples = 50,
        LastUpdate = 0
    },
    
    UpdateFPS = function(self)
        local currentTime = tick()
        table.insert(self.FPS.Samples, 1, currentTime)
        
        if #self.FPS.Samples > self.FPS.MaxSamples then
            table.remove(self.FPS.Samples)
        end
        
        if currentTime - self.FPS.LastUpdate >= 0.5 then
            local delta = self.FPS.Samples[1] - self.FPS.Samples[#self.FPS.Samples]
            self.FPS.Current = math.floor((#self.FPS.Samples - 1) / delta)
            self.FPS.LastUpdate = currentTime
        end
    end,
    
    ShouldUpdate = function(self, interval)
        return tick() - (self.LastUpdate or 0) >= (interval or 0.03)
    end
}

-- Carregar UI Library
local Lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/7yhx/kwargs_Ui_Library/main/source.lua"))()

-- Cache e Variáveis
local Cache = {
    ESP = {},
    Connections = {},
    DrawingObjects = {},
    LastUpdate = 0,
    UpdateInterval = 0.1
}

-- Configurações Visuais
local VisualSettings = {
    ESP = {
        BoxColors = {
            Enemy = Color3.fromRGB(255, 0, 0),
            Team = Color3.fromRGB(0, 255, 0),
            Target = Color3.fromRGB(255, 255, 0)
        },
        TextColors = {
            Primary = Color3.fromRGB(255, 255, 255),
            Secondary = Color3.fromRGB(200, 200, 200),
            Warning = Color3.fromRGB(255, 150, 0)
        },
        TracerStyles = {
            Default = {
                Thickness = 1,
                Color = Color3.fromRGB(255, 0, 0)
            },
            Target = {
                Thickness = 2,
                Color = Color3.fromRGB(255, 255, 0)
            }
        }
    },
    UI = {
        Colors = {
            Primary = Color3.fromRGB(30, 30, 35),
            Secondary = Color3.fromRGB(45, 45, 50),
            Accent = Color3.fromRGB(255, 0, 85),
            Text = Color3.fromRGB(255, 255, 255)
        }
    }
}

-- Configurações
local Config = {
    ESP = {
        Enabled = false,
        BoxStyle = {
            Type = "Corner",
            Thickness = 1.5,
            Transparency = 0.8,
            Animated = true
        },
        TextStyle = {
            Size = 14,
            Outline = true,
            Shadow = true
        },
        Features = {
            ShowDistance = true,
            ShowHealth = true,
            ShowWeapon = true,
            ShowTeam = true,
            ShowSkeleton = true,
            RainbowMode = false
        },
        Performance = {
            MaxDistance = 1000,
            UpdateRate = 0.1,
            SmoothUpdates = true
        }
    },
    Aimbot = {
        Enabled = false,
        Settings = {
            TeamCheck = true,
            VisibilityCheck = true,
            Smoothness = 0.5,
            Prediction = {
                Enabled = true,
                Amount = 0.15
            }
        },
        FOV = {
            Enabled = true,
            Size = 150,
            Color = Color3.fromRGB(255, 0, 85),
            Filled = false,
            Transparency = 0.5,
            Animated = true
        },
        Target = {
            Part = "Head",
            Priority = "Distance",
            Lock = "Hold",
            AutoShoot = false
        }
    }
}

-- Funções Utilitárias
local Utility = {
    IsAlive = function(player)
        local character = player.Character
        local humanoid = character and character:FindFirstChild("Humanoid")
        return character and humanoid and humanoid.Health > 0
    end,
    
    GetDistance = function(position)
        return (Camera.CFrame.Position - position).Magnitude
    end,
    
    WorldToViewport = function(position)
        local success, result = pcall(function()
            return Camera:WorldToViewportPoint(position)
        end)
        return success and result
    end,
    
    CreateDrawing = function(type, properties)
        local object = Drawing.new(type)
        for property, value in pairs(properties) do
            object[property] = value
        end
        return object
    end,
    
    DestroyDrawing = function(object)
        if object and object.Remove then
            object:Remove()
        end
    end,
    
    Rainbow = function(speed)
        return Color3.fromHSV(tick() % speed / speed, 1, 1)
    end
}

-- Sistema ESP
local ESP = {
    CreateESPObject = function(player)
        if player == LocalPlayer then return end
        
        local espObject = {
            Box = Utility.CreateDrawing("Square", {
                Thickness = Config.ESP.BoxStyle.Thickness,
                Color = VisualSettings.ESP.BoxColors.Enemy,
                Transparency = Config.ESP.BoxStyle.Transparency,
                Filled = false,
                Visible = false
            }),
            Name = Utility.CreateDrawing("Text", {
                Size = Config.ESP.TextStyle.Size,
                Center = true,
                Outline = Config.ESP.TextStyle.Outline,
                Color = VisualSettings.ESP.TextColors.Primary,
                Visible = false
            }),
            Distance = Utility.CreateDrawing("Text", {
                Size = Config.ESP.TextStyle.Size - 1,
                Center = true,
                Outline = Config.ESP.TextStyle.Outline,
                Color = VisualSettings.ESP.TextColors.Secondary,
                Visible = false
            }),
            Tracer = Utility.CreateDrawing("Line", {
                Thickness = VisualSettings.ESP.TracerStyles.Default.Thickness,
                Color = VisualSettings.ESP.TracerStyles.Default.Color,
                Transparency = 1,
                Visible = false
            })
        }
        
        Cache.ESP[player] = espObject
        return espObject
    end,
    
    UpdateESP = function()
        if not Config.ESP.Enabled then return end
        
        for player, espObject in pairs(Cache.ESP) do
            if not Utility.IsAlive(player) then
                ESP.HideESP(espObject)
                continue
            end
            
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then
                ESP.HideESP(espObject)
                continue
            end
            
            local distance = Utility.GetDistance(humanoidRootPart.Position)
            if distance > Config.ESP.Performance.MaxDistance then
                ESP.HideESP(espObject)
                continue
            end
            
            local vector, onScreen = Utility.WorldToViewport(humanoidRootPart.Position)
            if not onScreen then
                ESP.HideESP(espObject)
                continue
            end
            
            -- Atualizar elementos ESP
            ESP.UpdateBox(espObject, character, vector)
            ESP.UpdateText(espObject, player, vector, distance)
            ESP.UpdateTracer(espObject, vector)
        end
    end,
    
    UpdateBox = function(espObject, character, vector)
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if not (humanoid and rootPart) then return end
        
        local size = rootPart.Size * Vector3.new(1, 1.5, 1)
        local width = size.X * 1000 / vector.Z
        local height = size.Y * 1000 / vector.Z
        
        espObject.Box.Size = Vector2.new(width, height)
        espObject.Box.Position = Vector2.new(vector.X - width/2, vector.Y - height/2)
        espObject.Box.Visible = true
        
        if Config.ESP.Features.RainbowMode then
            espObject.Box.Color = Utility.Rainbow(Config.ESP.Performance.UpdateRate)
        end
    end,
    
    UpdateText = function(espObject, player, vector, distance)
        -- Nome
        espObject.Name.Text = player.Name
        espObject.Name.Position = Vector2.new(vector.X, vector.Y - 40)
        espObject.Name.Visible = true
        
        -- Distância
        if Config.ESP.Features.ShowDistance then
            espObject.Distance.Text = string.format("[%dm]", math.floor(distance))
            espObject.Distance.Position = Vector2.new(vector.X, vector.Y + 20)
            espObject.Distance.Visible = true
        end
    end,
    
    UpdateTracer = function(espObject, vector)
        local origin = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
        
        espObject.Tracer.From = origin
        espObject.Tracer.To = Vector2.new(vector.X, vector.Y)
        espObject.Tracer.Visible = true
    end,
    
    HideESP = function(espObject)
        for _, object in pairs(espObject) do
            object.Visible = false
        end
    end
}

-- Sistema Aimbot
local Aimbot = {
    Target = nil,
    
    GetClosestPlayer = function()
        local closestPlayer = nil
        local shortestDistance = Config.Aimbot.FOV.Size
        local mousePos = UserInputService:GetMouseLocation()
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if not Utility.IsAlive(player) then continue end
            
            local character = player.Character
            local humanoid = character:FindFirstChild("Humanoid")
            local targetPart = character:FindFirstChild(Config.Aimbot.Target.Part)
            
            if not (humanoid and targetPart) then continue end
            if humanoid.Health <= 0 then continue end
            
            if Config.Aimbot.Settings.TeamCheck and player.Team == LocalPlayer.Team then
                continue
            end
            
            local vector, onScreen = Utility.WorldToViewport(targetPart.Position)
            if not onScreen then continue end
            
            local distance = (Vector2.new(vector.X, vector.Y) - mousePos).Magnitude
            if distance < shortestDistance then
                if Config.Aimbot.Settings.VisibilityCheck then
                    local ray = Ray.new(Camera.CFrame.Position, 
                        (targetPart.Position - Camera.CFrame.Position).Unit * 1000)
                    local hit = workspace:FindPartOnRayWithIgnoreList(ray, 
                        {LocalPlayer.Character, character})
                    
                    if hit then continue end
                end
                
                closestPlayer = player
                shortestDistance = distance
            end
        end
        
        return closestPlayer
    end,
    
    Update = function()
        if not Config.Aimbot.Enabled then return end
        if not UserInputService:IsKeyDown(Config.Aimbot.Target.Lock) then return end
        
        local target = Aimbot.GetClosestPlayer()
        if not target then return end
        
        local character = target.Character
        local targetPart = character:FindFirstChild(Config.Aimbot.Target.Part)
        if not targetPart then return end
        
        local vector, onScreen = Utility.WorldToViewport(targetPart.Position)
        if not onScreen then return end
        
        -- Aplicar previsão se habilitada
        local targetPos = targetPart.Position
        if Config.Aimbot.Settings.Prediction.Enabled then
            targetPos = targetPos + (targetPart.Velocity * Config.Aimbot.Settings.Prediction.Amount)
        end
        
        -- Calcular nova posição da câmera
        local targetCFrame = CFrame.new(Camera.CFrame.Position, targetPos)
        
        -- Aplicar suavização
        Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, Config.Aimbot.Settings.Smoothness)
    end
}

-- Criar Interface
local Window = Lib:Create{
    Name = "Premium ESP & Aimbot",
    Theme = "Dark",
    Size = UDim2.new(0, 650, 0, 450),
    Acrylic = true
}

-- Criar Abas
local Tabs = {
    Combat = Window:Tab{
        Name = "Combat",
        Icon = "⚔️"
    },
    Visuals = Window:Tab{
        Name = "Visuals",
        Icon = "👁️"
    },
    Settings = Window:Tab{
        Name = "Settings",
        Icon = "⚙️"
    }
}

-- Aba Combat
local AimbotSection = Tabs.Combat:Section{
    Name = "Aimbot Settings",
    Side = "Left"
}

AimbotSection:Toggle{
    Name = "Enable Aimbot",
    Default = false,
    Callback = function(Value)
        Config.Aimbot.Enabled = Value
    end
}

AimbotSection:Slider{
    Name = "Smoothness",
    Default = 0.5,
    Min = 0,
    Max = 1,
    Increment = 0.1,
    Callback = function(Value)
        Config.Aimbot.Settings.Smoothness = Value
    end
}

AimbotSection:Dropdown{
    Name = "Target Part",
    Description = "Select target body part",
    Default = "Head",
    Options = {"Head", "Torso", "Random"},
    Callback = function(Value)
        Config.Aimbot.Target.Part = Value
    end
}

local AimbotAdvanced = Tabs.Combat:Section{
    Name = "Advanced Settings",
    Side = "Right"
}

AimbotAdvanced:Toggle{
    Name = "Prediction",
    Description = "Enable movement prediction",
    Default = true,
    Callback = function(Value)
        Config.Aimbot.Settings.Prediction.Enabled = Value
    end
}

AimbotAdvanced:ColorPicker{
    Name = "FOV Color",
    Description = "Adjust FOV circle color",
    Default = VisualSettings.ESP.BoxColors.Enemy,
    Callback = function(Color)
        Config.Aimbot.FOV.Color = Color
    end
}

-- Aba Visuals
local ESPSection = Tabs.Visuals:Section{
    Name = "ESP Settings",
    Side = "Left"
}

ESPSection:Toggle{
    Name = "Enable ESP",
    Default = false,
    Callback = function(Value)
        Config.ESP.Enabled = Value
    end
}

ESPSection:MultiDropdown{
    Name = "ESP Features",
    Description = "Select ESP elements to display",
    Default = {"Box", "Name", "Distance"},
    Options = {"Box", "Name", "Distance", "Health", "Weapon", "Skeleton", "Tracers"},
    Callback = function(Values)
        for feature, enabled in pairs(Values) do
            Config.ESP.Features["Show"..feature] = enabled
        end
    end
}

local VisualStyles = Tabs.Visuals:Section{
    Name = "Visual Style",
    Side = "Right"
}

VisualStyles:ColorPicker{
    Name = "Enemy Color",
    Description = "ESP color for enemies",
    Default = VisualSettings.ESP.BoxColors.Enemy,
    Callback = function(Color)
        VisualSettings.ESP.BoxColors.Enemy = Color
    end
}

VisualStyles:ColorPicker{
    Name = "Team Color",
    Description = "ESP color for teammates",
    Default = VisualSettings.ESP.BoxColors.Team,
    Callback = function(Color)
        VisualSettings.ESP.BoxColors.Team = Color
    end
}

-- Settings Tab
local ConfigSection = Tabs.Settings:Section{
    Name = "Configuration",
    Side = "Left"
}

ConfigSection:Button{
    Name = "Save Config",
    Description = "Save current settings",
    Callback = function()
        -- Implementar salvamento
        Window:Notify{
            Title = "Success",
            Description = "Configuration saved!",
            Duration = 2,
            Type = "Success"
        }
    end
}

ConfigSection:Button{
    Name = "Load Config",
    Description = "Load saved settings",
    Callback = function()
        -- Implementar carregamento
        Window:Notify{
            Title = "Success",
            Description = "Configuration loaded!",
            Duration = 2,
            Type = "Success"
        }
    end
}

local PerformanceSection = Tabs.Settings:Section{
    Name = "Performance",
    Side = "Right"
}

PerformanceSection:Slider{
    Name = "Update Rate",
    Description = "ESP update frequency",
    Default = 0.1,
    Min = 0.01,
    Max = 1,
    Increment = 0.01,
    ValueFormat = "%.2fs",
    Callback = function(Value)
        Config.ESP.Performance.UpdateRate = Value
    end
}

-- Info Tab
local InfoSection = Tabs.Info:Section{
    Name = "Information",
    Side = "Left"
}

InfoSection:Label{
    Text = "Premium ESP & Aimbot v1.0.0",
    Color = VisualSettings.ESP.BoxColors.Enemy
}

InfoSection:Label{
    Text = "Created by: [Your Name]",
    Color = VisualSettings.ESP.TextColors.Primary
}

InfoSection:Button{
    Name = "Copy Discord",
    Description = "Copy Discord invite link",
    Callback = function()
        setclipboard("your_discord_link")
        Window:Notify{
            Title = "Success",
            Description = "Discord link copied!",
            Duration = 2,
            Type = "Success"
        }
    end
}

-- Keybinds Section
local KeybindSection = Tabs.Settings:Section{
    Name = "Keybinds",
    Side = "Left"
}

KeybindSection:Keybind{
    Name = "Toggle UI",
    Description = "Show/Hide interface",
    Default = Enum.KeyCode.RightShift,
    Callback = function()
        Window:Toggle()
    end
}

KeybindSection:Keybind{
    Name = "Aimbot Key",
    Description = "Key to activate aimbot",
    Default = Enum.KeyCode.E,
    Callback = function(Key)
        Config.Aimbot.Target.Lock = Key
    end
}

-- Inicializar
local function Init()
    -- Conectar funções de atualização
    RunService:BindToRenderStep("ESP", 1, ESP.UpdateESP)
    RunService:BindToRenderStep("Aimbot", 2, Aimbot.Update)
    
    -- Manipulação de jogadores
    Players.PlayerAdded:Connect(function(player)
        ESP.CreateESPObject(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        if Cache.ESP[player] then
            for _, object in pairs(Cache.ESP[player]) do
                Utility.DestroyDrawing(object)
            end
            Cache.ESP[player] = nil
        end
    end)
    
    -- Inicializar jogadores existentes
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            ESP.CreateESPObject(player)
        end
    end
end

-- Iniciar o script
Init()
Window:Initialize() 
